use gl;
use gl::types::{
    GLint,
    GLuint,
    GLenum
};

use std::{
    ptr,
    str,
    fmt,
    ffi::CString,
    path::Path,
    collections::HashMap,
};
use super::bindable::Bindable;

// TODO: convert file to module

pub struct UniformError {
    is_gl_error: bool,
    error_code: GLenum,
}

pub const UNIFORM_NOT_FOUND: GLenum = 0;

impl fmt::Display for UniformError {
    /*
        GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.
        GL_INVALID_OPERATION is generated if program is not a program object.
        GL_INVALID_OPERATION is generated if program has not been successfully linked.
    */
    // TODO: less shitty error msgs
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self.is_gl_error {
            true => {
                match self.error_code {
                    gl::INVALID_VALUE => write!(f, "gl::INVALID_VALUE on uniform operation"),
                    gl::INVALID_OPERATION => write!(f, "gl::INVALID_OPERATION on uniform operation"),
                    i => write!(f, "unaccounted(1) {} for error on gl::GetUniformLocation", i)
                }
            },
            false => {
                match self.error_code {
                    UNIFORM_NOT_FOUND => write!(f, "Failed to find uniform value on gl::GetUniformLocation"),
                    i => write!(f, "unaccounted(2) '{}' for error on gl::GetUniformLocation", i)
                }
            }
        }
      
    }
}

// TODO: unique error for each program function?
impl UniformError {
    pub fn new(is_gl_error: bool, error_code: GLenum) -> Self {
        UniformError {
            is_gl_error,
            error_code
        }
    }
}


pub struct Program {
    pub program_id: u32,
    uniforms: HashMap<String, GLint> 
}

impl Bindable for Program {
    fn bind(&self) {
        unsafe {
            gl::UseProgram(self.program_id);
        }
    }

    fn unbind(&self) {
        unsafe {
            gl::UseProgram(0);
        }
    }
}

impl Program {
    pub fn find_uniform(&mut self, name: &str) -> Result<(), UniformError> {
        if let Some(_) = self.uniforms.get(name) {
            return Ok(());
        }

        let target_location = unsafe { 
            let mut active_program: GLint = 0;
            gl::GetIntegerv(gl::CURRENT_PROGRAM, &mut active_program);

            gl::UseProgram(self.program_id);
            let location = gl::GetUniformLocation(self.program_id, name.as_bytes().as_ptr() as *const i8);
            let error = gl::GetError();
            gl::UseProgram(active_program as GLuint);
            if error != gl::NO_ERROR {
                return Err(UniformError::new(true, error));
            }

            location
        };

        if target_location < 0 {
            return Err(UniformError::new(false, UNIFORM_NOT_FOUND));
        }

        self.uniforms.insert(name.to_string(), target_location);

        return Ok(());
    }

    pub fn set_uniform<T>(&self, name: &str, value: T, assign_fn: unsafe fn(GLint, T) -> ()) -> Result<(), UniformError> {
        let uniform_location: i32 = match self.uniforms.get(name) {
            Some(u) => *u,
            None => return Err(UniformError::new(false, UNIFORM_NOT_FOUND))
        };

        unsafe {
            let mut active_program: GLint = 0;
            gl::GetIntegerv(gl::CURRENT_PROGRAM, &mut active_program);

            gl::UseProgram(self.program_id);
            assign_fn(uniform_location, value);
            let error = gl::GetError();
            gl::UseProgram(active_program as GLuint);

            if error != gl::NO_ERROR {
                return Err(UniformError::new(true, error));
            }
        }

        Ok(())
    }

    // TODO: rename, not rust unsafe fn
    pub fn unsafe_set_uniform<T>(&self, name: &str, value: T, assign_fn: unsafe fn(GLint, T) -> ()) -> () {
        match self.set_uniform(name, value, assign_fn) {
            Ok(()) => return,
            Err(_) => return 
        }
    }
}

pub struct ProgramBuilder {
    program_id: u32,
    shaders: Vec::<u32>,
}

impl ProgramBuilder {
    pub fn new() -> ProgramBuilder {
        let program_id = unsafe {
            gl::CreateProgram()
        };

        ProgramBuilder {
            program_id,
            shaders: vec![],
        }
    }

    pub fn attach_file(self, shader_path: &str) -> ProgramBuilder {
        let path = Path::new(shader_path);
        if let Some(extension) = path.extension() {
            let shader_type = ShaderType::from_ext(extension)
                .expect("Failed to parse file extension.");
            let shader_src = std::fs::read_to_string(path)
                .expect(&format!("Failed to read shader source. {}", shader_path));

            self.compile_shader(&shader_src, shader_type)
        } else {
            panic!("Failed to read extension of file with path: {}", shader_path);
        }
    }

    pub fn compile_shader(mut self, shader_src: &str, shader_type: ShaderType) -> ProgramBuilder {
        let shader = unsafe {
            let shader = gl::CreateShader(shader_type.into());
            let c_str_shader = CString::new(shader_src.as_bytes()).unwrap();

            gl::ShaderSource(shader, 1, &c_str_shader.as_ptr(), ptr::null());
            gl::CompileShader(shader);
            if !self.check_shader_errors(shader) {
                panic!("Shader failed to compile.");
            }

            shader
        };

        self.shaders.push(shader);

        self
    }

    unsafe fn check_shader_errors(&self, shader_id: u32) -> bool {
        let mut success = i32::from(gl::FALSE);
        let mut info_log = Vec::with_capacity(512);

        info_log.set_len(512 - 1);
        gl::GetShaderiv(shader_id, gl::COMPILE_STATUS, &mut success);
        if success != i32::from(gl::TRUE) {
            gl::GetShaderInfoLog(
                shader_id,
                512,
                ptr::null_mut(),
                info_log.as_mut_ptr() as *mut gl::types::GLchar,
            );
            println!("ERROR::Shader Compilation Failed!\n{}", String::from_utf8_lossy(&info_log));
            return false;
        }

        true
    }

    unsafe fn check_linker_errors(&self) -> bool {
        let mut success = i32::from(gl::FALSE);
        let mut info_log = Vec::with_capacity(512);

        info_log.set_len(512 - 1);
        gl::GetProgramiv(self.program_id, gl::LINK_STATUS, &mut success);
        if success != i32::from(gl::TRUE) {
            gl::GetProgramInfoLog(
                self.program_id,
                512,
                ptr::null_mut(),
                info_log.as_mut_ptr() as *mut gl::types::GLchar,
            );
            println!("ERROR::SHADER::PROGRAM::COMPILATION_FAILED\n{}", String::from_utf8_lossy(&info_log));
            return false;
        }
        true
    }

    pub fn link(self) -> Program {
        unsafe {
            for &shader in &self.shaders {
                gl::AttachShader(self.program_id, shader);
            }
            gl::LinkProgram(self.program_id);
    
            // todo:: use this to make safer abstraction
            self.check_linker_errors();
    
            for &shader in &self.shaders {
                gl::DeleteShader(shader);
            }
        }

        Program {
            program_id: self.program_id,
            uniforms: HashMap::new()
        }
    }
}

#[allow(dead_code)]
pub enum ShaderType {
    Vertex,
    Fragment,
    TessellationControl,
    TessellationEvaluation,
    Geometry,
}

impl ShaderType {
    fn from_ext(ext: &std::ffi::OsStr) -> Result<ShaderType, String> {
        match ext.to_str().expect("Failed to read extension") {
            "vert" => { Ok(ShaderType::Vertex) },
            "frag" => { Ok(ShaderType::Fragment) },
            "tcs"  => { Ok(ShaderType::TessellationControl) },
            "tes"  => { Ok(ShaderType::TessellationEvaluation) },
            "geom" => { Ok(ShaderType::Geometry) },
            e => { Err(e.to_string()) },
        }
    }
}

impl Into<gl::types::GLenum> for ShaderType {
    fn into(self) -> gl::types::GLenum {
        match self {
            ShaderType::Vertex                  => { gl::VERTEX_SHADER          },
            ShaderType::Fragment                => { gl::FRAGMENT_SHADER        },
            ShaderType::TessellationControl     => { gl::TESS_CONTROL_SHADER    },
            ShaderType::TessellationEvaluation  => { gl::TESS_EVALUATION_SHADER } ,
            ShaderType::Geometry                => { gl::GEOMETRY_SHADER        },
        }
    }
}




